define(['./shared'], (function (actor) { 'use strict';

const CONFIG = { workerUrl: "" };

let _actor;
let id = 0;
class MainThreadDispatch {
    constructor() {
        this.decodeImage = (blob, encoding, abortController) => actor.p(actor.d(blob, encoding, abortController), false);
    }
}
function defaultActor() {
    if (!_actor) {
        const worker = new Worker(CONFIG.workerUrl);
        const dispatch = new MainThreadDispatch();
        _actor = new actor.A(worker, dispatch);
    }
    return _actor;
}
/**
 * Caches, decodes, and processes raster tiles in a shared web worker.
 */
class RemoteDemManager {
    constructor(options) {
        this.fetchTile = (z, x, y, abortController, timer) => this.actor.send("fetchTile", [], abortController, timer, this.managerId, z, x, y);
        this.fetchAndParseTile = (z, x, y, abortController, timer) => this.actor.send("fetchAndParseTile", [], abortController, timer, this.managerId, z, x, y);
        this.fetchContourTile = (z, x, y, options, abortController, timer) => this.actor.send("fetchContourTile", [], abortController, timer, this.managerId, z, x, y, options);
        const managerId = (this.managerId = ++id);
        this.actor = options.actor || defaultActor();
        this.loaded = this.actor.send("init", [], new AbortController(), undefined, Object.assign(Object.assign({}, options), { managerId }));
    }
}

if (!Blob.prototype.arrayBuffer) {
    Blob.prototype.arrayBuffer = function arrayBuffer() {
        return new Promise((resolve, reject) => {
            const fileReader = new FileReader();
            fileReader.onload = (event) => { var _a; return resolve((_a = event.target) === null || _a === void 0 ? void 0 : _a.result); };
            fileReader.onerror = reject;
            fileReader.readAsArrayBuffer(this);
        });
    };
}
const v3compat = (v4) => (requestParameters, arg2) => {
    if (arg2 instanceof AbortController) {
        return v4(requestParameters, arg2);
    }
    else {
        const abortController = new AbortController();
        v4(requestParameters, abortController)
            .then((result) => arg2(undefined, result.data, result.cacheControl, result.expires), (err) => arg2(err))
            .catch((err) => arg2(err));
        return { cancel: () => abortController.abort() };
    }
};
const used = new Set();
/**
 * A remote source of DEM tiles that can be connected to maplibre.
 */
class DemSource {
    constructor({ url, cacheSize = 100, id = "dem", encoding = "terrarium", maxzoom = 12, worker = true, timeoutMs = 10000, actor: actor$1, }) {
        this.timingCallbacks = [];
        /** Registers a callback to be invoked with a performance report after each tile is requested. */
        this.onTiming = (callback) => {
            this.timingCallbacks.push(callback);
        };
        /**
         * Adds contour and shared DEM protocol handlers to maplibre.
         *
         * @param maplibre maplibre global object
         */
        this.setupMaplibre = (maplibre) => {
            maplibre.addProtocol(this.sharedDemProtocolId, this.sharedDemProtocol);
            maplibre.addProtocol(this.contourProtocolId, this.contourProtocol);
        };
        /**
         * Callback to be used with maplibre addProtocol to re-use cached DEM tiles across sources.
         */
        this.sharedDemProtocolV4 = (request, abortController) => actor._(this, void 0, void 0, function* () {
            const [z, x, y] = this.parseUrl(request.url);
            const timer = new actor.T("main");
            let timing;
            try {
                const data = yield this.manager.fetchTile(z, x, y, abortController, timer);
                timing = timer.finish(request.url);
                const arrayBuffer = yield data.data.arrayBuffer();
                return {
                    data: arrayBuffer,
                    cacheControl: data.cacheControl,
                    expires: data.expires,
                };
            }
            catch (error) {
                timing = timer.error(request.url);
                throw error;
            }
            finally {
                this.timingCallbacks.forEach((cb) => cb(timing));
            }
        });
        /**
         * Callback to be used with maplibre addProtocol to generate contour vector tiles according
         * to options encoded in the tile URL pattern generated by `contourProtocolUrl`.
         */
        this.contourProtocolV4 = (request, abortController) => actor._(this, void 0, void 0, function* () {
            const timer = new actor.T("main");
            let timing;
            try {
                const [z, x, y] = this.parseUrl(request.url);
                const options = actor.a(request.url);
                const data = yield this.manager.fetchContourTile(z, x, y, actor.g(options, z), abortController, timer);
                timing = timer.finish(request.url);
                return { data: data.arrayBuffer };
            }
            catch (error) {
                timing = timer.error(request.url);
                throw error;
            }
            finally {
                this.timingCallbacks.forEach((cb) => cb(timing));
            }
        });
        this.contourProtocol = v3compat(this.contourProtocolV4);
        this.sharedDemProtocol = v3compat(this.sharedDemProtocolV4);
        /**
         * Returns a URL with the correct maplibre protocol prefix and all `option` encoded in request parameters.
         */
        this.contourProtocolUrl = (options) => `${this.contourProtocolUrlBase}?${actor.e(options)}`;
        let protocolPrefix = id;
        let i = 1;
        while (used.has(protocolPrefix)) {
            protocolPrefix = id + i++;
        }
        used.add(protocolPrefix);
        this.sharedDemProtocolId = `${protocolPrefix}-shared`;
        this.contourProtocolId = `${protocolPrefix}-contour`;
        this.sharedDemProtocolUrl = `${this.sharedDemProtocolId}://{z}/{x}/{y}`;
        this.contourProtocolUrlBase = `${this.contourProtocolId}://{z}/{x}/{y}`;
        const ManagerClass = worker ? RemoteDemManager : actor.L;
        this.manager = new ManagerClass({
            demUrlPattern: url,
            cacheSize,
            encoding,
            maxzoom,
            timeoutMs,
            actor: actor$1,
        });
    }
    getDemTile(z, x, y, abortController) {
        return this.manager.fetchAndParseTile(z, x, y, abortController || new AbortController());
    }
    parseUrl(url) {
        const [, z, x, y] = /\/\/(\d+)\/(\d+)\/(\d+)/.exec(url) || [];
        return [Number(z), Number(x), Number(y)];
    }
}

const exported = {
    generateIsolines: actor.c,
    DemSource,
    HeightTile: actor.H,
    LocalDemManager: actor.L,
    decodeParsedImage: actor.b,
    set workerUrl(url) {
        CONFIG.workerUrl = url;
    },
    get workerUrl() {
        return CONFIG.workerUrl;
    },
};

return exported;

}));
